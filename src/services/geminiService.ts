import { GeminiResponse, GeminiApiResponse } from '../types';

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const GEMINI_API_URL = import.meta.env.VITE_GEMINI_API_URL || 'https://generativelanguage.googleapis.com/v1beta';

export class GeminiService {
  private static validateApiKey(): boolean {
    return !!GEMINI_API_KEY && GEMINI_API_KEY !== 'your_gemini_api_key_here';
  }

  static async generateClarifyingQuestions(idea: string, instructions: string): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const systemPrompt = `You are a professional prompt engineer. Your task is to generate 3-6 clarifying questions to refine a user's raw idea into an optimized AI prompt.

Based on the user's idea and instructions, generate questions that cover:
- Target audience
- Tone/style (formal, casual, persuasive, storytelling, etc.)
- Level of detail/length
- Keywords/constraints
- Output format
- Examples if relevant

For each question, provide 3-5 suggested answer options that users can select from.

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "clarifyingQuestions": [
    {
      "text": "Question 1",
      "options": ["Option A", "Option B", "Option C", "Option D"]
    },
    {
      "text": "Question 2", 
      "options": ["Option A", "Option B", "Option C"]
    }
  ]
}

User's Instructions: ${instructions}
User's Idea: ${idea}`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          clarifyingQuestions: [
            {
              text: 'Who is the target audience for this prompt?',
              options: ['General audience', 'Technical professionals', 'Students', 'Business executives', 'Creative professionals']
            },
            {
              text: 'What tone and style should the AI use?',
              options: ['Professional/Formal', 'Conversational/Casual', 'Persuasive', 'Educational', 'Creative/Storytelling']
            },
            {
              text: 'What is the desired length or format?',
              options: ['Brief summary', 'Detailed explanation', 'Step-by-step guide', 'Bullet points', 'Essay format']
            },
            {
              text: 'Should the AI provide examples or illustrations?',
              options: ['Yes, with examples', 'Yes, with analogies', 'No examples needed', 'Visual descriptions', 'Case studies']
            }
          ]
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }

  static async generateOptimizedPrompt(
    idea: string, 
    instructions: string, 
    answeredQuestions: Array<{ question: string; answer: string }>
  ): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const clarifications = answeredQuestions
      .map(q => `Q: ${q.question}\nA: ${q.answer}`)
      .join('\n\n');

    const systemPrompt = `You are a professional prompt engineer. Create an optimized, AI-ready prompt using the template pattern below.

## Prompt Template Pattern:
Role: <Define AI's role clearly>
Task: <Define what to produce/do>
Context: <Background or scenario if needed>
Constraints:
- <Constraint 1>
- <Constraint 2>
Style/Tone: <Formal, Conversational, Persuasive, etc.>
Audience: <Who will receive the output>
Format: <Headings, bullet points, JSON, essay, etc.>
Mandatory Details / Keywords: <Words or themes that must appear>

<Integrated version of the user's idea, instructions, and clarifications>

## Inputs:
User's Original Idea: ${idea}
Overarching Instructions: ${instructions}
Clarifications: ${clarifications}

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "optimizedPrompt": "The final optimized prompt here following the template pattern"
}

Make the prompt clear, structured, unambiguous, and easy for an AI to follow.`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          optimizedPrompt: responseText
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }
}