import { GeminiResponse, GeminiApiResponse } from '../types';

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const GEMINI_API_URL = import.meta.env.VITE_GEMINI_API_URL || 'https://generativelanguage.googleapis.com/v1beta';

export class GeminiService {
  private static validateApiKey(): boolean {
    return !!GEMINI_API_KEY && GEMINI_API_KEY !== 'your_gemini_api_key_here';
  }

  static async generateClarifyingQuestions(idea: string, instructions: string): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const systemPrompt = `You are a professional prompt engineer. Your task is to generate 3-6 clarifying questions to refine a user's raw idea into an optimized AI prompt.

Based on the user's idea and instructions, generate questions that cover:
- Target audience
- Tone/style (formal, casual, persuasive, storytelling, etc.)
- Level of detail/length
- Keywords/constraints
- Output format
- Examples if relevant

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "clarifyingQuestions": [
    "Question 1",
    "Question 2", 
    "Question 3"
  ]
}

User's Instructions: ${instructions}
User's Idea: ${idea}`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          clarifyingQuestions: [
            'Who is the target audience for this prompt?',
            'What tone and style should the AI use?',
            'What is the desired length or format?',
            'Should the AI provide examples or illustrations?',
            'Are there specific keywords or constraints to include?'
          ]
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }

  static async generateOptimizedPrompt(
    idea: string, 
    instructions: string, 
    answeredQuestions: Array<{ question: string; answer: string }>
  ): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const clarifications = answeredQuestions
      .map(q => `Q: ${q.question}\nA: ${q.answer}`)
      .join('\n\n');

    const systemPrompt = `You are a professional prompt engineer. Create an optimized, AI-ready prompt using the template pattern below.

## Prompt Template Pattern:
Role: <Define AI's role clearly>
Task: <Define what to produce/do>
Context: <Background or scenario if needed>
Constraints:
- <Constraint 1>
- <Constraint 2>
Style/Tone: <Formal, Conversational, Persuasive, etc.>
Audience: <Who will receive the output>
Format: <Headings, bullet points, JSON, essay, etc.>
Mandatory Details / Keywords: <Words or themes that must appear>

<Integrated version of the user's idea, instructions, and clarifications>

## Inputs:
User's Original Idea: ${idea}
Overarching Instructions: ${instructions}
Clarifications: ${clarifications}

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "optimizedPrompt": "The final optimized prompt here following the template pattern"
}

Make the prompt clear, structured, unambiguous, and easy for an AI to follow.`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          optimizedPrompt: responseText
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }
}