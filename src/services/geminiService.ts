import { GeminiResponse, GeminiApiResponse } from '../types';

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const GEMINI_API_URL = import.meta.env.VITE_GEMINI_API_URL || 'https://generativelanguage.googleapis.com/v1beta';

export class GeminiService {
  private static validateApiKey(): boolean {
    return !!GEMINI_API_KEY && GEMINI_API_KEY !== 'your_gemini_api_key_here';
  }

  static async generatePromptingStyles(idea: string, instructions: string): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const systemPrompt = `You are a professional prompt engineer. Analyze the user's idea and instructions, then recommend the 2-3 most relevant prompting styles from this list:

[Instruction-based, Role/Persona, Format-Constrained, Few-shot, Zero-shot, Chain-of-Thought, Socratic, Storytelling, Roleplay, Hypothetical, Critique & Improve, Iterative Refinement]

For each recommended style, provide:
1. A 1-2 sentence explanation in plain language
2. A short example snippet showing how it would apply to this specific idea

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "suggestedStyles": [
    {
      "id": "role-persona",
      "name": "Role/Persona",
      "explanation": "The AI takes on a specific role or character to provide more targeted responses.",
      "example": "You are an experienced travel blogger who writes engaging, personal stories about destinations..."
    }
  ]
}

User's Instructions: ${instructions}
User's Idea: ${idea}`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          suggestedStyles: [
            {
              id: 'instruction-based',
              name: 'Instruction-based',
              explanation: 'Clear, direct instructions that tell the AI exactly what to do.',
              example: 'Write a comprehensive travel guide for...'
            },
            {
              id: 'role-persona',
              name: 'Role/Persona',
              explanation: 'The AI takes on a specific role or character to provide more targeted responses.',
              example: 'You are an experienced travel blogger who...'
            }
          ]
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }

  static async generateClarifyingQuestions(idea: string, instructions: string): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const systemPrompt = `You are a professional prompt engineer. Generate 5-6 highly specific clarifying questions tailored to this user's exact idea and instructions. These questions must be custom and relevant, not generic templates.

Examples of good custom questions:
- If idea is "travel blog generator" → ask about tone (casual vs professional), content length, target audience
- If idea is "math tutor roleplay" → ask about subject, grade level, step-by-step reasoning
- If idea is "creative writing assistant" → ask about genre, writing style, character development focus

For each question, provide 3-5 specific answer options that users can select from (they can select multiple or add custom text).

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "clarifyingQuestions": [
    {
      "text": "What specific tone should the content have?",
      "options": ["Professional and informative", "Casual and conversational", "Enthusiastic and inspiring", "Humorous and entertaining"]
    }
  ]
}

User's Instructions: ${instructions}
User's Idea: ${idea}`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          clarifyingQuestions: [
            {
              text: 'What specific tone should the content have?',
              options: ['Professional and informative', 'Casual and conversational', 'Enthusiastic and inspiring', 'Humorous and entertaining']
            },
            {
              text: 'What level of detail is needed?',
              options: ['Brief overview', 'Detailed explanation', 'Comprehensive guide', 'Quick reference']
            },
            {
              text: 'Who is the primary audience?',
              options: ['Beginners', 'Intermediate users', 'Experts', 'General public']
            },
            {
              text: 'What format should the output use?',
              options: ['Structured paragraphs', 'Bullet points', 'Step-by-step list', 'Q&A format']
            }
          ]
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }

  static async generateOptimizedPrompt(
    idea: string, 
    instructions: string, 
    answeredQuestions: Array<{ question: string; answer: string }>,
    appliedStyles: string[]
  ): Promise<GeminiResponse> {
    if (!this.validateApiKey()) {
      return { status: 'error', error: 'Gemini API key missing' };
    }

    const clarifications = answeredQuestions
      .map(q => `Q: ${q.question}\nA: ${q.answer}`)
      .join('\n\n');

    const stylesText = appliedStyles.length > 0 ? appliedStyles.join(', ') : 'General instruction-based';

    const systemPrompt = `You are a professional prompt engineer. Create an optimized, AI-ready prompt that explicitly incorporates these prompting styles: ${stylesText}

Use this template pattern:

Role: <Define AI's role clearly>
Task: <Define what to produce/do>
Context: <Background or scenario if needed>
Style Application: <How the chosen styles are applied>
Constraints:
- <Constraint 1>
- <Constraint 2>
Style/Tone: <Formal, Conversational, Persuasive, etc.>
Audience: <Who will receive the output>
Format: <Headings, bullet points, JSON, essay, etc.>
Mandatory Details / Keywords: <Words or themes that must appear>

<Integrated version of the user's idea, instructions, and clarifications>

## Inputs:
User's Original Idea: ${idea}
Overarching Instructions: ${instructions}
Applied Styles: ${stylesText}
Clarifications: ${clarifications}

Return your response as a JSON object with this exact format:
{
  "status": "success",
  "optimizedPrompt": "The final optimized prompt here following the template pattern",
  "appliedStyles": ${JSON.stringify(appliedStyles)}
}

Make the prompt clear, structured, unambiguous, and explicitly incorporate the chosen prompting styles.`;

    try {
      const response = await fetch(`${GEMINI_API_URL}/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: systemPrompt
            }]
          }]
        })
      });

      if (!response.ok) {
        return { status: 'error', error: `Gemini API error: ${response.status}` };
      }

      const data: GeminiApiResponse = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        return { status: 'error', error: 'No response generated by AI' };
      }

      const responseText = data.candidates[0].content.parts[0].text;
      
      try {
        const parsedResponse = JSON.parse(responseText);
        return parsedResponse;
      } catch {
        // Fallback if JSON parsing fails
        return {
          status: 'success',
          optimizedPrompt: responseText,
          appliedStyles: appliedStyles
        };
      }
    } catch (error) {
      return { status: 'error', error: `Network error: ${error}` };
    }
  }
}